# CP01

## Objective
 - C++ STL에 있는 몇몇 컨테이너에 대해 구현해라
 - 각각의 표준 컨테이너를 레퍼런스로 삼아라. 만일 레퍼런스가 정식 클래스 형식이 아니면 정식 형식으로 구현하지 마라
 - C++98이후의 기능들에 대해서는 절대 구현하지 말아라, 하지만 c++98의 기능은 모두 구현하라

# CP02

## General Rules

### Compiling
 - -Wall -Werror -Wextra -std=c++98 플래그를 사용하여 컴파일하라

### Formatting and naming conventions
 - 각 컨테이너에 대한 적절한 파일 클래스 이름을 적어라
 - 어떠한 코딩 스타일도 강제되지 않으니 자유롭게 작성해라, 하지만 평가자가 읽을 수 있도록 최대한 깔끔하게 작성해라

### Allowed/Forbidden
 - C가 아닌 C++을 코딩하는 중이다. 그러니
   - 표준 라이브러리의 모든 함수가 사용가능하다. 그러니 이미 알고 있는 것들만 사용하지 말고 C++식 새로운 함수들을 많이 사용해봐라
   - 하지만 C++11이나 Boost 라이브러리같은 외부 라이브러리는 사용이 불가능하다. 또한 `printf()`, `malloc()`, `free()`함수들도 사용이 불가능하다.

### A few design requirements
 - 메모리 누수가 나면 안된다.
 - 템플릿 함수를 제외한 함수들을 헤더 파일에서 정의하면 안된다.
 - 각 헤더를 다른 헤더와 독립적으로 사용할 수 있어야 하므로 필요한 모든 종속성을 포함해야 한다. 하지만 동일한 헤더의 중복적용을 막기 위해 헤더가드를 사용해야 한다.

### Read me
 - 코드 분할등 필요한 경우 파일을 추가할 수 있고, 과제를 수행하는 동안 원하는 대로 작업을 구상할 수 있다.
 - STL을 리코딩하는 과제인 만큼 STL은 사용하면 안된다.

# CP03

## Mandatory Part
 - 다음 컨테이너들을 구현하고 `<컨테이너>.hpp` 파일로 제출해라
   - `vector` : `vector<bool>` 특수정의는 필요없다
   - `map`
   - `stack` : 본인이 만든 벡터 클래스를 기본 컨테이너로 사용하고, STL이 포함된 다른 컨테이너와 호환되어야 한다.
 - 이것들 또한 구현되어야 한다
   - iterators_traits
   - reverse_iterator
   - enable_if : C++11구조이지만 C++98에 맞춰 구현하라. 이걸 구현하면서 SFINAE를 찾아보아라
   - is_integral
   - equal, lexicographical_compare 둘 중 하나 혹은 둘 다
   - std::pair
   - std::make_pair

## 3-1.Requirements
 - 네임스페이스는 `ft`여야 한다
 - 컨테이너에 사용되는 각 내부 데이터 구조는 논리적의고 정당해야 한다.
 - 표준 컨테이너보다 더 많은 퍼블릭 함수들을 만들면 안 된다. 나머지들은 프라이빗 혹은 프로텍티드여야 한다. 각각의 퍼블릭 변수 혹은 함수들은 정당해야 한다.
 - 표준 컨테이너의 모든 멤버함수, 비멤버함수, 오버로딩을 구현해야 한다.
 - 원본의 이름을 따라해야 한다.
 - 컨테이너에 반복자 시스템이 있으면 그것 또한 구현해야 한다
 - `std::allocator`을 사용해야 한다
 - 비멤버 오버로딩에 관해서 `friend`키워드의 사용이 허용된다. 각각의 `friend`사용은 정당해야 하고, 평가 때 확인될 것이다.
 - `map::value_compare`에 관해서도 `friend`키워드의 사용이 허용된다.

## 3-2.Test
 - 디펜스를 위한 main.cpp 테스트가 제공된다. 이보다 더 많은 테스트를 시행해봐라
 - 본인의 컨테이너만을 쓰는 것, STL 컨테이너를 쓰는 것, 총 두 개의 바이너리 파일을 만들어라
 - 두 개의 출력과 퍼포먼스를 비교해 보아라
 - 본안의 컨테이너를 테스트할 때에는 `ft::<container>`를 사용해라

